\documentclass[letterpaper,12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{graphicx, subfigure}
\usepackage{longtable}
\usepackage{amsmath,amsfonts}
\usepackage{array}
\usepackage{xspace}
\usepackage{color, fancyvrb, relsize}
\usepackage{url, hyperref}
\usepackage{algorithm, algorithmic, listings}
\usepackage[francais]{babel}
\selectlanguage{francais}

\input{scheme}
\lstloadlanguages{Scheme}
\lstset{language=Scheme}
\textheight=600pt

% commande qui fait en sorte que seul les Section sont numerottees
%% \setcounter{secnumdepth}{1}
% \setcounter{page}{0}
\newcommand{\forcenewline}[0]{\begin{center}\end{center}}

\begin{document}

\title{IFT6232 - Étape 3: Optimisations d'évaluations partielles et
  système d'objets polymorphes pour Gambit-C}

\author{par Jérémie Lasalle Ratelle et David St-Hilaire}
\maketitle

\clearpage

\tableofcontents

\clearpage

\chapter{Systèmes d'objets}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Les languages de programmations se distinguent par différents concepts
ou caractéristiques qui leurs sont propres. Le language Scheme est
caractérisé non seulement par son système de macro très évolué et par
les foncitons de premières classes, mais aussi par sa
\emph{simplicité}.

En effet, Scheme est un language très minimaliste. Il fut conçu de
manière à comprendre tous les outils nécessaire, afin d'en avoir aussi
peu que possible, contrairement à Lisp où l'approche inverse est
utilisée. Ainsi, pour programmer en Scheme des programmes non
triviaux, plusieurs librairies auxiliaires doivent être généralement
écrites. Par contre, puisque le language est très expressifs, ces
librairies peuvent être écrites rapidement.

Un module intéressant à ajouter au dessus de Scheme est un système
orienté objet. En effet, un tel système permet la création et
l'utilisation d'objets de manières très dynamique et expressive par,
entre autre, l'utilisation du polymorphisme et de l'héritage.

Nous proposons donc pour la troisième étape de notre projet d'écrire
un système d'objets pouvant s'ajouter à Scheme pour d'une part,
obtenir un module utile pour tout programmeur Scheme et, d'autre part,
démontrer qu'il est possible d'écrire rapidement un système qui peut
sembler très complexe à première vu en utilisant la puissance
expressive de Scheme.

\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Besoins et Contraintes}
    Le système de programmation orienté objet conçu respecte plusieurs
    contraintes dans le but de répondre à des besoins
    correspondant. Ces contraintes sont donc indiquées dans cette
    section en ordre d'importance.

    \subsection{Rapidité d'accès aux champs}
      Cette contrainte est la plus importante pour notre implantation
      du système objet. En effet, les accès aux champs des objets sont
      des opérations extrêmement fréquentes et donc, afin d'avoir un
      système utilisable à l'intérieur d'applications concrètes, ces
      accès doivent se faire le plus rapidement possible afin de
      diminuer l'impacte du coût de l'utilisaiton d'un système
      d'objets.

    \subsection{Rapidité de choix d'instances de fonction générique}
      De manière similaire à la contrainte reliée à l'accès aux
      champs, notre système objets doit permettre d'obtenir rapidement
      l'instance correspondant à un appel de fonction générique. Cette
      contrainte impose donc aux fonctions générique de ne pas évaluer
      dynamiquement quelle serait la meilleure instance d'une fonction
      générique pour les types des objets passés en paramètres.

    \subsection{Modularité}
      Le système doit être facile à intégrer à une application écrite
      en Scheme. Donc elle devrait pouvoir être incluse comme toute
      librairie et ne pas être intégrée directement dans une
      implantation de Scheme, pour faciliter l'utilisation.

    \subsection{Interface à la CLOS}
      Le système d'objet devrait avoir une interface similaire à celle
      fournie par le système objets du language Common
      Lisp~\cite{COMMONLISP} (Common Lisp Object System, ou encore
      CLOS). Puisque Scheme est une version épurée de Common Lisp et
      puisque CLOS est déjà bien connu et à fait ses preuves en tant
      qu'utilisabilité, il serait donc naturel qu'un système d'objets
      pour Scheme respecte des conventions d'utilisations et des
      concepts similaires à ceux qui sont déjà bien connu chez CLOS,
      afin d'augmenter l'accessibilité du système.
    
    \subsection{Développement intéractif}
      Il serait intéressant que le système permette de pouvoir faire
      du développement itératif (de manière interactive avec un REPL)
      de manière à ce que le système soit cohérent avec la philosophie
      de développement généralement utilisée en Scheme, \textit{i.e.}
      de régulièrement tester le code écrit de manière interprétée.
      Par contre, le fait de permettre ne devrait pas nuire aux
      performances du système, surtout si on désire que ce système
      soit compilé (et donc exécuté rapidement).

    \subsection{Portabilité relative}
      Finalement, il serait pertinant que système soit écrit de
      manière portable afin qu'il puisse être utilisé dans plusieurs
      implantation de Scheme. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Interface de Programmation (\texttt{API})}
    \label{api}

    Cette section contient un aperçu du système d'objet implanté, et
    décrit brièvement son utilisation.
  
    \subsection{Création de Classes et d'Objets}
      La forme spéciale \texttt{define-class} permet de déclarer une
      nouvelle classe (ou d'en redéfinir une existante). Cette forme
      spéciale possède grossièrement la forme suivante:

      \begin{lstlisting}
(define-method class-name (supers) slots...)
      \end{lstlisting}

      où \texttt{class-name} est le nom de la class définie,
      \texttt{supers} est une liste des super-classes de la classes
      définie et \texttt{slots...} sera des définitions des champs de
      l'objets.

      Les champs peuvent être soient présents dans chaque instances
      (obtenu par \texttt{(slot: nom)} ou commun à toutes les
      instances (obtenu par \texttt{(class-slot: nom)}. De plus, il
      existe des options pour les champs:
      
      \begin{itemize}
      \item[\texttt{read-hook:}] Permet de passer en paramètre
        plusieurs fonctions qui seront appellées avant chaque lecture
        du champs.
      \item[\texttt{write-hook:}] Permet de passer en paramètre
        plusieurs fonctions qui seront appellées avant chaque écriture
        du champs.
      \end{itemize}

      Lorsque ces options sont activées pour des champs d'instances,
      les fonctions doivent avoir une signature comme:
      \texttt{(lambda(obj val) ...)}, sinon si le champs est une
      champs de classe, la signature des fonctions devraient
      ressembler à: \texttt{(lambda(val)...)}.

      Un exemple (figure \ref{ex-defclass}) illustre de manière
      général la définition de classes.

      \begin{figure}[htbp!]
        \begin{lstlisting}
(define-class A () 
  (slot: a (read-hooks: (lambda (o v) (pp v)))))
(define-class B () 
  (slot: b (write-hooks: (lambda (o new-v) (pp new-v)))))
(define-class C (A B) (class-slot: c))
        \end{lstlisting}
        \caption{Exemple de définition de class}
        \label{ex-defclass}
      \end{figure}

      Une déclaraiton de classe résulte en la création de plusieurs
      fonctions utilitaires. Par exemple pour une définition comme
      \begin{lstlisting}
(define-class A () (slot: a) (class-slot: b))}
      \end{lstlisting}
      on obtiendrait:

      \begin{itemize}
      \item[\texttt{(make-A a)}:] Fonction de création d'une instance
        de la classe \texttt{A}. Prend en paramètre les valeurs des
        champs d'instances, en commençant par les champs hérités, dans
        l'ordre (récursif) donné des super classes, tel qu'illustré
        dans la figure \ref{ex-make-instance}.
        \begin{figure}[h!]
          \begin{lstlisting}
(define-class A ()   (slot: a))
(define-class B (A)  (slot: b))
(define-class C ()   (slot: c))
(define-class D (A C) (slot: d))
(make-D a b c d)
          \end{lstlisting}
          \caption{Exemple illustrant l'ordre des paramètre dans un
            constructeur d'instances.}
          \label{ex-make-instance}
        \end{figure}
      \item[]

      \item[\texttt{(A? obj)}:] Prédicat qui test si l'objet passé en
        paramètre est une instance ou une sous-classe de \texttt{A}.
      \item[]

      \item[\texttt{(A-a obj)}:] Accès au champs d'instance \texttt{a}
        de l'objet passé en paramètre.
      \item[]

      \item[\texttt{(A-a-set! obj new-a)}:] Modification du champs
        d'instance \texttt{a} de l'objet passé en paramètre.
      \item[]

      \item[\texttt{(A-b)}:] Accès au champs statique \texttt{b}.
      \item[]

      \item[\texttt{(A-b-set! new-b)}:] Modificationdu champs
        statique \texttt{b}.
      \item[]

      \item[\texttt{(describe obj)}:] Instance de fonction générique
        qui retourne une liste décrivant le contenu de
        l'instance. Utilise pour visualiser le contenu avec
        \texttt{(pp (describe obj))}.
      \end{itemize}

    \subsection{Déclaration et Instanciation de Fonctions Génériques}

      \subsubsection{Déclarations de fonctions génériques}
        La déclaration de fonctions génériques se fait par l'utilisation
        de la forme spéciale suivante:

      \begin{lstlisting}
(define-generic (fname arg1 arg2 ...))
      \end{lstlisting}

        Cette déclaration indique donc la présence d'une nouvelle
        fonction générique avec son arité (et le nom de chacun de ses
        paramètres).

        Par la suite, les instances des fonctions génériques peuvent
        être déclarées par la forme spéciale:

      \begin{lstlisting}
(define-method (fname (arg1 arg1-type) arg2))
      \end{lstlisting}

        où l'on peut optionnelement spécifier le type (symbole
        correspondant au nom de la classe) de l'argument
        passé. Lorsqu'aucune indication de type n'est donnée, le type
        par défaut aux données Scheme (\texttt{any-type}) est
        attribué.

      \subsubsection{Relation d'ordre sur les classes}
        Les fonctions génériques de notre système implante un
        polymorphisme plus simple que celui disponible avec un système
        aussi puissant que CLOS. Entre autre, nos fonctions génériques
        ne permettent pas d'utiliser des appels à d'autres instances
        comme \texttt{call-next-method}.

        Ainsi, lors de l'appel, l'instance de la fonction générique la
        \og meilleure \fg sera utilisée. Afin de trouver quelle
        instance est la meilleure pour des arguments de types donnés,
        une heuristique très simple est utilisée: ce sera l'instance
        qui devra avoir des paramètres tous super-types des paramètres
        actuels et dont la somme pour chaque argument formels des
        nombres de super classes sera la plus grande. Cette
        heuristique est utilisée pour sa simplicité et parce qu'elle
        semble donner un comportement prédictible, mais c'est le
        résultat d'un choix assez arbitraire.

      \subsubsection{Invoquation d'instances}

        Comme mentionné, la meilleure instance de la fonction
        générique appellé, selon des arguments donnés, sera appellée
        lors d'une invoquation. Bien sûr, les fonction génériques
        effectuent du \og dispatch \fg multiple, et donc elles ne sont
        pas limitées à un seul argument (figure \ref{ex-multdisp}).

        \begin{figure}[h!]
          \begin{lstlisting}
> (define-generic (f (x A) y (z A) zz))
> (define-method (f (x A) y (z A) zz)
    (+ (A-a x) y (A-a z) (string->number zz)))
> (define-method (f (x A) y z zz)
    (+ (A-a x) y z zz))
> (f (make-A 1) 2 (make-A 3) "4")
10
> (f (make-A 1) 2 3 4)
10
          \end{lstlisting}
          \caption{Exemple d'invoquation d'une fonction générique et
            du \og dispatch \fg multiple en résultant.}
          \label{ex-multdisp}
        \end{figure}
        
        Par contre, il est aussi possible d'invoquer une instance
        particulière d'une fonction générique en utilisant un \og cast
        \fg. Dans l'exemple illustré dans la figure \ref{ex-cast},

        \begin{figure}[h!]
          \begin{lstlisting}
> (define-class A () (slot: a))
> (define-class B (A) (slot: b))
> (define-class C (B) (slot: c))
> (define-generic (f x))
> (define-method (f (x A)) (A-a x))
> (define-method (f (x B)) (B-b x))
> (f (make-C 1 2 3))
2
> (f (cast (make-C 1 2 3) 'A))
1
          \end{lstlisting}
          \caption{Exemple illustrant l'utilisation du \og cast \fg
            disponible appeller une instance spécifique d'une fonction
            générique.}
          \label{ex-cast}
        \end{figure}

      \subsubsection{Modes d'utilisations}

        Deux modes de programmations sont définis pour le système
        objet, tout particulièrement pour l'utilisation des fonctions
        génériques. Le premier mode, le mode itératif (par défaut),
        permet de définir et d'invoquer directement les nouvelles
        instances, comme illustré dans les figure \ref{ex-cast} et
        figure \ref{ex-multdisp}. Ce mode est très utile pour du
        développement intéractif, comme c'est souvent le cas en
        Scheme. 

        Un second mode est aussi disponible, le mode manuel, qui
        permettrait d'installer les instances de fonctions génériques,
        sur demande, et non pas après chaque définitions de nouvelles
        instances. Ce mode devient innévitable lorsqu'on compile du
        code utilisant le système.

        On peut donc choisir le mode désiré en utilisant les formes
        spéciales:

        \begin{lstlisting}
(set-iterative-method-developpement!) ; par defaut
(set-manual-method-developpement!)
        \end{lstlisting}

        Il est fortement de recommandé de choisir le mode
        immédiatement après l'inclusion du système objet.

    \subsection{Outils additionnels disponibles à l'exécution}

      Plusieurs fonctionnalités sont displonible durant l'éxécution du
      système d'objets afin de rendre plus agréable son
      utilisation. Les fonctions principales sont:

      \begin{itemize}
      \item[\texttt{(find-class 'class-name)}:] Permet d'obtenir le
        descripteur de classe de la classe nommée
        \texttt{class-name}, si elle existe.
      \item[]
      \item[\texttt{(class-desc-id class-descriptor)}:] Retourne le
        nom de la classe passée en paramètre.
      \item[]
      \item[\texttt{(class-desc-supers class-descriptor)}:] Retourne
        la liste des super classes directes de la classe donnée.
      \item[]
      \item[\texttt{(object? obj)}:] Prédicat vérifiant si l'objet
        donnée est une instance d'une classe du système.
      \item[]
      \item[\texttt{(get-class-id obj)}:] Retourne le nom symbolique
        de la classe de l'objet donnée. Si l'objet n'est pas une
        instance, alors \texttt{'any-type} est retourné.
      \item[]
      \item[\texttt{(instance-of? obj 'class-name)}:] Vérifie de
        manière efficace si l'objet est une instance directe de la
        classe associée au symbol donné.
      \item[]
      \item[\texttt{(object-light-copy obj)}:] Créé une copie légère
        de l'instance passée en paramètre. Une copy légère créé une
        nouvelle instance, ne fais que copier les pointeurs contenu
        dans l'instance.
      \end{itemize}

      Aussi, une forme spéciale (\texttt{update!}) est disponible pour
      faire une mise-à-jour incrémentale d'un champs d'instance. Une
      mise-à-jour incrémentale survient lorsque qu'on modifie un
      champs en fonction de sa valeur courante. La figure
      \ref{ex-update-a} illustre un exemple typique de mise-à-jour
      incrémentale et la figure \ref{ex-update-b} illustre un exemple
      d'utilisation de la forme spéciale équivalent.

      \begin{figure}[h!]
          \begin{lstlisting}
(define-class position () (slot: x) (slot: y))
(let ((current-position (make-position 3 4)))
    (position-x-set! current-position
                     (+ (position-x current-position) 5)))
          \end{lstlisting}
          \caption{Exemple typique de mise-à-jour incrémentale}
          \label{ex-update-a}
      \end{figure}

      \begin{figure}[h!]
          \begin{lstlisting}
(define-class position () (slot: x) (slot: y))
(let ((current-position (make-position 3 4)))
    (update! current-position position x (lambda (x) (+ x 5))))
          \end{lstlisting}
          \caption{Code équivalent utilisant la forme spéciale
            \texttt{update!}}
          \label{ex-update-b}
      \end{figure}

    Bien sûr, l'utilisation de cette macro n'est pas nécessaire, mais
    permet souvent de faire de manière plus courte une mise-à-jour
    incrémentale.

\clearpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implantation}

  Dans cette section, l'implantation du système objets décrit dans la
  section \ref{api} sera décrite. Ainsi, les structures de données et
  algorithmes seront expliqués afin d'expliquer le fonctionnement du
  système et les choix qui ont dû être fait afin de resepecter le
  mieux possible les contraintes imposées initialement.

  \subsection{Classes et Objets}j
    \label{classes&objets}
    La forme spéciale de déclaration de classe (\texttt{define-class})
    est implanté dans notre système comme une macro Scheme. Cette
    macro prends les paramètre passés en entrés, soit le nom de la
    classe, la liste des super classes et les champs de celle-ci et
    effectue le traitement nécessaire afin de pouvoir générer le code
    permettant d'obtenir le comportement décrit plus haut.

    Le traitement nécessaire est relativement simple et se fait en 3
    étapes:

    \begin{enumerate}
    \item Traitement des champs hérités des super classes
    \item Traitement des champs directs de la classe
    \item Génération de code
    \end{enumerate}

    \subsubsection{Traitement des champs hérités des super classes}
   
      Afin d'obtenir les champs hérités des super classes, les super
      classes sont passées dans l'ordre spécifié par
      l'utilisateur. Les champs de chaque super classes sont ajoutés à
      une \og eq? table \fg utilisé temporairement
      (\texttt{temp-field-table}). On vérifie aussi que les champs ne
      sont pas héritées plus d'une fois, sinon on retourne une
      erreur. Bien sûr, une vérification assure que toutes les classes
      sont des classes valides du système. La figure
      \ref{heritage-code} illustre ce traitement.
   
      \begin{figure}[h!]
        \begin{lstlisting}
  (for-each
   (lambda (super)
     (let ((super-field-indices
            (cond
             ((table-ref class-table super #f) =>
              (lambda (desc) (class-info-fi desc)))
             (else (error "Inexistant super class")))))
       (for-each
        (lambda (field-index)
          (if (not (table-ref temp-field-table (car field-index) 
                               #f))
              (table-set! temp-field-table
                          (car field-index) (cdr field-index))
              (error "Field already defined")))
        super-field-indices)))
   supers)
        \end{lstlisting}
        \caption{Code effectuant le traitement des champs hérités}
        \label{heritage-code}
      \end{figure}
      
      Maintenant que les champs hérités sont en mains, il ne suffit que de
      traiter les champs directs de la classe.

    \subsubsection{Traitement des champs directs de la classe}
      Par la suite, les champs directs de la classe sont traités. Le
      traitement effectue le \og parsing \fg des champs en s'assurant
      qu'ils sont bien formés. Par la suite, une verification assure
      que le champs n'existe pas dans les champs hérités, si c'est le
      cas, alors le champs hérité est utilisé.

      Encore une fois, l'information sur les champs est ajouté dans la
      \og eq? table \fg temporaire.

      \begin{figure}[h!]
        \begin{lstlisting}
(define (process-field! field)
  (cond
   ((and (list? field)
         (>= (length field) 2))
    (let ((slot-type (case (car field)
                         ((slot: class-slot:) (car field))
                         (else (error "Bad slot type!"))))
          (slot-name (cadr field))
          (slot-options (cddr field)))
      ;; If a field is already provided by a super class
      ;; then the super class's is used ...
      (if (not (table-ref temp-field-table slot-name #f))
          (table-set! temp-field-table
                      slot-name
                      (make-slot slot-type
                                 (next-desc-index)
                                 slot-options)))))
   (else "ill-formed slot declaration")))
(for-each process-field! fields)
        \end{lstlisting}
        \caption{Code effectuant le traitement des champs hérités}
        \label{heritage-code}
      \end{figure}

      Lorsque toute l'information sur les champs est en main, il est
      maintenant possible d'effectuer la génération de code implantant
      la création et manipulation d'instances de cette nouvelle classe.

    \subsubsection{Génération de code}
      En ce qui a attraît à la génération du code exécuté, le logique
      est très simple. Elle se résume bien par le code effectuant le
      travail (figure \ref{class-code-gen})

      \begin{figure}[h!]
        \begin{lstlisting}
  (let* ((field-indices (sort-field-indices
                             (table->list temp-field-table)))
          (class-desc (gen-descriptor field-indices)))
    (table-set! class-table name 
                 (make-class-info field-indices class-desc))
    `(begin ,@(gen-accessors field-indices)
             ,@(gen-setters field-indices)
             ,(gen-predicate)
             ,(gen-instantiator field-indices)
             ,(gen-printfun field-indices)
             (table-set! ,(rt-class-table-name)
                          ',name
                          ,(class-desc-name name))))
        \end{lstlisting}
        \caption{Génération de code par un appel à \texttt{define-class}}
        \label{class-code-gen}
      \end{figure}

      Ainsi, on constate que la table temporaire de champs est
      transformée en structure de donnée qui sera conservée tout au
      long de la phase d'expansion macro, via une table globale
      contenant toutes les classes déclarées
      (\texttt{class-table}). Par la suite, les fonctions nécessaires
      sont générées à partir de ces données de manière à ce que
      l'accès au champs ce fasse rapidement, mais sans utiliser trop
      d'espace mémoire non plus. Plus de détails sur la structure des
      instances et l'accès au champs sont donnés dans la section
      \ref{inst-struct}.

      Il est à noter que le code généré par \texttt{gen-instantiator}
      créé une variable globale à l'exécution qui possèdera un
      pointeur direct vers le descripteur de class. On peut ainsi
      accèder très facilement aux champs de classes. Par contre, un
      pointeur vers le descripteur de classe est aussi placé dans une
      table de hachage (similaire à celle présente lors de l'expansion
      macro) afin de permettre plus de flexibilité.
  
  \subsection{Fonctions Génériques}

  \subsection{Structures de données à l'exécution}
    Les structures de données utilisées pour implanter les classes,
    fonctions génériques et instances de ces deux derniers à
    l'exécution sont décrite dans cette section.
  
    \subsubsection{Descripteur de classes}
      Les descripteurs de classes sont les objets représentant la méta
      entité qu'est une classe. Le rôle que joue le descripteur dans
      notre système est primordial, car c'est lui qui permet de dire
      au fonctions accédant aux champs où retrouver ces derniers. On
      peut résumé la structure d'un descripteur de classe par le
      vecteur Scheme suivant:

      \begin{lstlisting}
#(nom-classe liste-supers . indexes)
      \end{lstlisting}

      Nous avons consciemment utilisé le point comme un abus de
      notation dans ce vecteur afin de représenter que le reste du
      vecteur correspond a des indices pour \emph{tout les champs de
        toutes les classes}. Lorsque les champs sont ajoutés à un
      descripteur de nouvelle classe, les nouveaux champs sont ajoutés
      à la suite des champs précédemment existant dans toutes les
      classes déjà déclarées. Ainsi, chaque champs possède un index
      \emph{unique} dans les descripteurs de classes.

      Ce choix résulte forcémment en de larges descripteurs de classes,
      surtout lorsrqu'il y a beaucoup de classes ou des classes
      possédant beaucoup de champs. Par contre, ceci permet d'avoir
      toute la flexibilité désirée pour la création d'instances. 

      Donc, dans le descripteur de classe, à l'index pré-déterminer pour
      un champs donné, on y retrouvera l'index où se trouve ce champs en
      question dans une instance de la classe. On pourra donc avoir des
      instances de taille constante. Le coût de se choix résulte par
      contre, en une indirection supplémentaire pour l'accès à un champs
      (il faut aller chercher où se trouve le champs dans l'instance à
      partir de l'information contenue dans le descripteur de classe).

      Afin d'illustrer ce qui vient d'être énnoncé, l'exemple présenté
      dans la figure \ref{ex-cdesc} illustre les descripteurs de classes
      créés lorsque le système est \og frais \fg et qu'aucune autre
      classe n'existe au préalable. On constate que par exemple, pour la
      classe \texttt{C}, l'index d'instance du champs \texttt{zz} se
      retrouve après trois \og trous \fg correspondant aux champs des
      classes \texttt{A} et \texttt{B} et sa valeur d'index d'instance
      est de 1.

      \begin{figure}[h!]
        \begin{lstlisting}
> (include "class.scm")
object-system-loaded
> (define-class A () (slot: a))
> (find-class? 'A)
#(A () 1)
> (define-class B (A) (slot: b) (slot: c))
> (find-class? 'B)
#(B (A) 1 2 3)
> (define-class C () (slot: zz))
> (find-class? 'C)
#(C () unknown-slot unknown-slot unknown-slot 1)
        \end{lstlisting}
        \caption{Exemple illustrant le comportement des descripteurs de
          classes. Les descripteurs de classes grossissent de plus en
          plus qu'il y a de classes déclarées.}
        \label{ex-cdesc}
      \end{figure}

    \subsubsection{Structure des instances}
      \label{inst-struct}
      Les instances sont représentées de manière très simple. Il
      s'agit d'un vecteur dont le premier champs est un pointeur vers
      le descripteur de classe et les autres contiennent les champs
      d'instances, dans l'ordre tel que décrit dans l'api (voir
      section \ref{api}) ou dans le traitement déclarations de classes
      (voir section \ref{classes&objets}). En reprenant les
      déclarations de classes de la figure \ref{ex-cdesc}, la figure
      \ref{ex-struct-inst} illustre la structure des instances de ces
      classes \texttt{A}, \texttt{B} et \texttt{C}.

      \begin{figure}[h!]
        \begin{lstlisting}
> (make-A 'allo)
#(#(A () 1) allo)
> (make-B 'allo 'toto 'titi)
#(#(B (A) 1 2 3) allo toto titi)
> (make-C 'bonjour)
#(#(C () unknown-slot unknown-slot unknown-slot 1) bonjour)
        \end{lstlisting}
        \caption{Illustration de la structure des instances de classes à
          partir des définitions de classes données dans la figure
          \ref{ex-cdesc}.}
        \label{ex-struct-inst}
      \end{figure}

      Malgré le fait que les instances semblent d'augmenter de tailles
      en fonction du nombres de classes précédemment définies, ce n'est
      pas le cas puisqu'il ne s'agit que d'un pointeur vers le
      descripteur de classe.

      Ainsi, un accès à un champs se fait en temps constant ($\in
      O(1)$). Il faut parcontre suivre deux indirections: une pour
      obtenir le descripteur de classe et une seconde par le
      descripteur de classe afin de savoir où se trouve le champs dans
      l'instance. Par contre, l'accès aux champs de classes sont
      directs puisque ceux-ci sont stockés directement dans le
      descripteur de classe (où il y aurait normalement l'index
      d'instance). Ce concept est illustré dans l'exemple
      \ref{ex-slot-access}, où le code effectuant l'accès à des champs
      d'instance et de classe est donnée pour une classe exemple.

      \begin{figure}[h!]
        \begin{lstlisting}
> (define-class D () (slot: inst) (class-slot: clas))
> (find-class? 'D)
#(D () 1 unbound-class-slot)
> (##decompile D-inst)
(lambda (#:obj1373) (vector-ref #:obj1373 
                        (vector-ref (vector-ref #:obj1373 0) 2)))
> (##decompile D-clas)
(lambda () (vector-ref D-class-descriptor 3))
> (D-clas-set! 'allo)
> (find-class? 'D)
#(D () 1 allo)
        \end{lstlisting}
        \caption{Illustration du code effectuant l'accès aux champs
          d'instances et de classes.}
        \label{ex-slot-access}
      \end{figure}

    \subsubsection{Structure des fonction génériques et de leurs instances}
    
    

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Résultats}

\clearpage

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Limitations}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{R\'ef\'erences}
\bibliographystyle{abbrv}
\bibliography{bibliography}



\end{document}
