\documentclass[letterpaper,12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{graphicx, subfigure}
\usepackage{longtable}
\usepackage{amsmath,amsfonts}
\usepackage{array}
\usepackage{xspace}
\usepackage{color, fancyvrb, relsize}
\usepackage{url, hyperref}
\usepackage{algorithm, algorithmic, listings}
\usepackage[francais]{babel}
\selectlanguage{francais}

\input{scheme}
\lstloadlanguages{Scheme}
\lstset{language=Scheme}
\textheight=600pt

% commande qui fait en sorte que seul les Section sont numerottees
%% \setcounter{secnumdepth}{1}
% \setcounter{page}{0}
\newcommand{\forcenewline}[0]{\begin{center}\end{center}}

\begin{document}

\title{IFT6232 - Étape 3: Optimisations d'évaluations partielles et
  système d'objets polymorphes pour Gambit-C}

\author{par Jérémie Lasalle Ratelle et David St-Hilaire}
\maketitle

\clearpage

\tableofcontents

\clearpage

\chapter{Systèmes d'objets}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Les languages de programmations se distinguent par différents concepts
ou caractéristiques qui leurs sont propres. Le language Scheme est
caractérisé non seulement par son système de macro très évolué et par
les foncitons de premières classes, mais aussi par sa
\emph{simplicité}.

En effet, Scheme est un language très minimaliste. Il fut conçu de
manière à comprendre tous les outils nécessaire, afin d'en avoir aussi
peu que possible, contrairement à Lisp où l'approche inverse est
utilisée. Ainsi, pour programmer en Scheme des programmes non
triviaux, plusieurs librairies auxiliaires doivent être généralement
écrites. Par contre, puisque le language est très expressifs, ces
librairies peuvent être écrites rapidement.

Un module intéressant à ajouter au dessus de Scheme est un système
orienté objet. En effet, un tel système permet la création et
l'utilisation d'objets de manières très dynamique et expressive par,
entre autre, l'utilisation du polymorphisme et de l'héritage.

Nous proposons donc pour la troisième étape de notre projet d'écrire
un système d'objets pouvant s'ajouter à Scheme pour d'une part,
obtenir un module utile pour tout programmeur Scheme et, d'autre part,
démontrer qu'il est possible d'écrire rapidement un système qui peut
sembler très complexe à première vu en utilisant la puissance
expressive de Scheme.

\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Besoins et Contraintes}
    Le système de programmation orienté objet conçu respecte plusieurs
    contraintes dans le but de répondre à des besoins
    correspondant. Ces contraintes sont donc indiquées dans cette
    section en ordre d'importance.

    \subsection{Rapidité d'accès aux champs}
      Cette contrainte est la plus importante pour notre implantation
      du système objet. En effet, les accès aux champs des objets sont
      des opérations extrêmement fréquentes et donc, afin d'avoir un
      système utilisable à l'intérieur d'applications concrètes, ces
      accès doivent se faire le plus rapidement possible afin de
      diminuer l'impacte du coût de l'utilisaiton d'un système
      d'objets.

    \subsection{Rapidité de choix d'instances de méthode générique}
      De manière similaire à la contrainte reliée à l'accès aux
      champs, notre système objets doit permettre d'obtenir rapidement
      l'instance correspondant à un appel de fonction générique. Cette
      contrainte impose donc aux fonctions générique de ne pas évaluer
      dynamiquement quelle serait la meilleure instance d'une fonction
      générique pour les types des objets passés en paramètres.

    \subsection{Modularité}
      Le système doit être facile à intégrer à une application écrite
      en Scheme. Donc elle devrait pouvoir être incluse comme toute
      librairie et ne pas être intégrée directement dans une
      implantation de Scheme, pour faciliter l'utilisation.

    \subsection{Interface à la CLOS}
      Le système d'objet devrait avoir une interface similaire à celle
      fournie par le système objets du language Common
      Lisp~\cite{COMMONLISP} (Common Lisp Object System, ou encore
      CLOS). Puisque Scheme est une version épurée de Common Lisp et
      puisque CLOS est déjà bien connu et à fait ses preuves en tant
      qu'utilisabilité, il serait donc naturel qu'un système d'objets
      pour Scheme respecte des conventions d'utilisations et des
      concepts similaires à ceux qui sont déjà bien connu chez CLOS,
      afin d'augmenter l'accessibilité du système.
    
    \subsection{Développement intéractif}
      Il serait intéressant que le système permette de pouvoir faire
      du développement itératif (de manière interactive avec un REPL)
      de manière à ce que le système soit cohérent avec la philosophie
      de développement généralement utilisée en Scheme, \textit{i.e.}
      de régulièrement tester le code écrit de manière interprétée.
      Par contre, le fait de permettre ne devrait pas nuire aux
      performances du système, surtout si on désire que ce système
      soit compilé (et donc exécuté rapidement).

    \subsection{Portabilité relative}
      Finalement, il serait pertinant que système soit écrit de
      manière portable afin qu'il puisse être utilisé dans plusieurs
      implantation de Scheme. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Interface de Programmation (\texttt{API})}
    Cette section contient un aperçu du système d'objet implanté, et
    décrit brièvement son utilisation.
  
    \subsection{Création de Classes et d'Objets}
      La forme spéciale \texttt{define-class} permet de déclarer une
      nouvelle classe (ou d'en redéfinir une existante). Cette forme
      spéciale possède grossièrement la forme suivante:

      \begin{lstlisting}
(define-method class-name (supers) slots...)
      \end{lstlisting}

      où \texttt{class-name} est le nom de la class définie,
      \texttt{supers} est une liste des super-classes de la classes
      définie et \texttt{slots...} sera des définitions des champs de
      l'objets.

      Les champs peuvent être soient présents dans chaque instances
      (obtenu par \texttt{(slot: nom)} ou commun à toutes les
      instances (obtenu par \texttt{(class-slot: nom)}. De plus, il
      existe des options pour les champs:
      
      \begin{itemize}
      \item[\texttt{read-hook:}] Permet de passer en paramètre
        plusieurs fonctions qui seront appellées avant chaque lecture
        du champs.
      \item[\texttt{write-hook:}] Permet de passer en paramètre
        plusieurs fonctions qui seront appellées avant chaque écriture
        du champs.
      \end{itemize}

      Lorsque ces options sont activées pour des champs d'instances,
      les fonctions doivent avoir une signature comme:
      \texttt{(lambda(obj val) ...)}, sinon si le champs est une
      champs de classe, la signature des fonctions devraient
      ressembler à: \texttt{(lambda(val)...)}.

      Un exemple (figure \ref{ex-defclass}) illustre de manière
      général la définition de classes.

      \begin{figure}[htbp!]
        \begin{lstlisting}
(define-class A () 
  (slot: a (read-hooks: (lambda (o v) (pp v)))))
(define-class B () 
  (slot: b (write-hooks: (lambda (o new-v) (pp new-v)))))
(define-class C (A B) (class-slot: c))
        \end{lstlisting}
        \caption{Exemple de définition de class}
        \label{ex-defclass}
      \end{figure}

      Une déclaraiton de classe résulte en la création de plusieurs
      fonctions utilitaires. Par exemple pour une définition comme
      \begin{lstlisting}
(define-class A () (slot: a) (class-slot: b))}
      \end{lstlisting}
      on obtiendrait:

      \begin{itemize}
      \item[\texttt{(make-A a)}:] Fonction de création d'une instance
        de la classe \texttt{A}. Prend en paramètre les valeurs des
        champs d'instances, en commençant par les champs hérités, dans
        l'ordre (récursif) donné des super classes, tel qu'illustré
        dans la figure \ref{ex-make-instance}.
        \begin{figure}[h!]
          \begin{lstlisting}
(define-class A ()   (slot: a))
(define-class B (A)  (slot: b))
(define-class C ()   (slot: c))
(define-class D (A C) (slot: d))
(make-D a b c d)
          \end{lstlisting}
          \caption{Exemple illustrant l'ordre des paramètre dans un
            constructeur d'instances.}
          \label{ex-make-instance}
        \end{figure}
      \item[]

      \item[\texttt{(A? obj)}:] Prédicat qui test si l'objet passé en
        paramètre est une instance ou une sous-classe de \texttt{A}.
      \item[]

      \item[\texttt{(A-a obj)}:] Accès au champs d'instance \texttt{a}
        de l'objet passé en paramètre.
      \item[]

      \item[\texttt{(A-a-set! obj new-a)}:] Modification du champs
        d'instance \texttt{a} de l'objet passé en paramètre.
      \item[]

      \item[\texttt{(A-b)}:] Accès au champs statique \texttt{b}.
      \item[]

      \item[\texttt{(A-b-set! new-b)}:] Modificationdu champs
        statique \texttt{b}.
      \item[]

      \item[\texttt{(describe obj)}:] Instance de fonction générique
        qui retourne une liste décrivant le contenu de
        l'instance. Utilise pour visualiser le contenu avec
        \texttt{(pp (describe obj))}.
      \end{itemize}

    \subsection{Déclaration et Instanciation de Méthodes Génériques}

      \subsubsection{Relation d'ordre sur les classes}
        \label{rel-ordre}

    \subsection{Outils additionnels disponibles à l'exécution}

\clearpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implantation}

\subsection{Classes et Objets}

\subsection{Méthodes Génériques}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Résultats}

%%   \begin{figure}[htbp!]
%%     \begin{lstlisting}
%% (let ((x (if j (cons 1 2) (cons 3 4))))
%%   (let ((y (##pair? x)))
%%     y))
%%     \end{lstlisting}
%%     \caption{Code source illustrant le \og constant folding \fg de la
%%       fonction \texttt{pair?}.}
%%     \label{ex3-source1}
%%   \end{figure}


\clearpage

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Limitations}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{R\'ef\'erences}
\bibliographystyle{abbrv}
\bibliography{bibliography}



\end{document}
